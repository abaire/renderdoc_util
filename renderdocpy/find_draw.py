# RenderDoc Python console, powered by python 3.9.7.
# The 'pyrenderdoc' object is the current CaptureContext instance.
# The 'renderdoc' and 'qrenderdoc' modules are available.
# Documentation is available: https://renderdoc.org/docs/python_api/index.html

from contextlib import redirect_stdout
import os
import struct

rd = renderdoc
context = pyrenderdoc
replay_manager = context.Replay()


class MeshData(rd.MeshFormat):
    indexOffset = 0
    name = ""


class ActionDescription:
    def __init__(self, event_id):
        self.event_id = event_id
        self.topology = 0
        self.num_indices = -1
        self.color_targets = []
        self.depth_targets = []
        self.textures = []

    def __str__(self):
        lines = [
            f"EID: {self.event_id}",
            f"  Primitive: {TOPOLOGY.get(self.topology)} ({self.topology})",
            f"  NumIndices: {self.num_indices}",
        ]

        lines.extend([f"  Color: {target}" for target in self.color_targets])
        lines.extend([f"  Depth: {target}" for target in self.depth_targets])
        lines.extend(
            [f"  Uses: {target} in sampler {bind}" for target, bind in self.textures]
        )

        return "\n".join(lines)


TOPOLOGY = {
    1: "Points",
    2: "Lines",
    3: "LineLoop",
    4: "LineStrip",
    5: "Triangles",
    6: "TriangleStrip",
    7: "TriangleFan",
    8: "Quads",
    9: "QuadStrip",
    10: "Polygon",
}


def _get_mesh_indices(controller, mesh):
    # Get the character for the width of index
    indexFormat = "B"
    if mesh.indexByteStride == 2:
        indexFormat = "H"
    elif mesh.indexByteStride == 4:
        indexFormat = "I"

    # Duplicate the format by the number of indices
    indexFormat = str(mesh.numIndices) + indexFormat

    # If we have an index buffer
    if mesh.indexResourceId != rd.ResourceId.Null():
        # Fetch the data
        ibdata = controller.GetBufferData(mesh.indexResourceId, mesh.indexByteOffset, 0)

        # Unpack all the indices, starting from the first index to fetch
        offset = mesh.indexOffset * mesh.indexByteStride
        indices = struct.unpack_from(indexFormat, ibdata, offset)

        # Apply the baseVertex offset
        return [i + mesh.baseVertex for i in indices]
    else:
        # With no index buffer, just generate a range
        return tuple(range(mesh.numIndices))


# Get a list of MeshData objects describing the vertex inputs at this draw
def _get_mesh_inputs(controller, draw):
    state = controller.GetPipelineState()

    # Get the index & vertex buffers, and fixed vertex inputs
    ib = state.GetIBuffer()
    vbs = state.GetVBuffers()
    attrs = state.GetVertexInputs()

    meshInputs = []

    for attr in attrs:

        # We don't handle instance attributes
        if attr.perInstance:
            raise RuntimeError("Instanced properties are not supported!")

        meshInput = MeshData()
        meshInput.indexResourceId = ib.resourceId
        meshInput.indexByteOffset = ib.byteOffset
        meshInput.indexByteStride = ib.byteStride
        meshInput.baseVertex = draw.baseVertex
        meshInput.indexOffset = draw.indexOffset
        meshInput.numIndices = draw.numIndices

        # If the draw doesn't use an index buffer, don't use it even if bound
        if not (draw.flags & rd.ActionFlags.Indexed):
            meshInput.indexResourceId = rd.ResourceId.Null()

        # The total offset is the attribute offset from the base of the vertex
        meshInput.vertexByteOffset = (
            attr.byteOffset
            + vbs[attr.vertexBuffer].byteOffset
            + draw.vertexOffset * vbs[attr.vertexBuffer].byteStride
        )
        meshInput.format = attr.format
        meshInput.vertexResourceId = vbs[attr.vertexBuffer].resourceId
        meshInput.vertexByteStride = vbs[attr.vertexBuffer].byteStride
        meshInput.name = attr.name

        meshInputs.append(meshInput)

    return meshInputs


def _describe_mesh(action, pipeline, description):
    description.topology = pipeline.GetPrimitiveTopology()

    def _print_mesh_info(controller):
        mesh_inputs = _get_mesh_inputs(controller, action)
        indices = _get_mesh_indices(controller, mesh_inputs[0])
        description.num_indices = len(indices)

    replay_manager.BlockInvoke(_print_mesh_info)


def _describe_surface(action, pipeline, description):
    fb = pipeline.framebuffer
    if not fb:
        return
    draw_fbo = fb.drawFBO
    if not draw_fbo:
        return

    for index, resource in enumerate(draw_fbo.colorAttachments):
        resource_id = resource.resourceId
        if resource_id == rd.ResourceId.Null():
            continue
        resource_descr = pyrenderdoc.GetResource(resource_id)
        if resource_descr.autogeneratedName:
            continue
        description.color_targets.append(resource_descr.name)

    depth = draw_fbo.depthAttachment
    if depth:
        resource_id = depth.resourceId
        if resource_id != rd.ResourceId.Null():
            resource_descr = pyrenderdoc.GetResource(resource_id)
            if not resource_descr.autogeneratedName:
                description.depth_targets.append(resource_descr.name)

    psh = pipeline.fragmentShader
    bindpoint_mapping = psh.bindpointMapping

    ro_inputs = bindpoint_mapping.readOnlyResources
    rw_inputs = bindpoint_mapping.readWriteResources

    def _capture_textures(resources):
        for resource in resources:
            if not resource.isTexture:
                continue

            bindpoint_array = ro_inputs if resource.isReadOnly else rw_inputs
            bindpoint = bindpoint_array[resource.bindPoint]
            if not bindpoint.used:
                continue
            texture = pipeline.textures[resource.bindPoint]
            resource_id = texture.resourceId

            resource_descr = pyrenderdoc.GetResource(resource_id)
            if resource_descr.autogeneratedName:
                continue
            description.textures.append((resource_descr.name, resource.bindPoint))

    _capture_textures(psh.reflection.readOnlyResources)
    _capture_textures(psh.reflection.readWriteResources)

    print("")


def iterate_draw_actions(action):
    while action:
        if action.flags & rd.ActionFlags.Drawcall:
            yield action
        action = action.next


def find_surface(filter_func=None, write_to_file=True):
    current_filename = os.path.basename(context.GetCaptureFilename())

    def _go():
        for action in iterate_draw_actions(context.CurRootActions()[0]):
            if not action.flags & rd.ActionFlags.Drawcall:
                action = action.next
                continue
            context.SetEventID([], action.eventId, action.eventId, False)
            # Renderdoc GLPipelineState does not subclass the abstracted state.
            pipeline = context.CurPipelineState()
            gl_pipeline = context.CurGLPipelineState()
            if not gl_pipeline:
                action = action.next
                continue

            description = ActionDescription(action.eventId)
            _describe_mesh(action, pipeline, description)
            _describe_surface(action, gl_pipeline, description)

            if not filter_func or filter_func(description):
                print(f"{description}\n")

    if write_to_file:
        output = os.path.expanduser(f"~/Desktop/{current_filename}_surfaces.txt")
        with open(output, "w", encoding="utf-8") as out_file:
            with redirect_stdout(out_file):
                _go()
    else:
        _go()


def _filter(description: ActionDescription) -> bool:
    return True


find_surface(_filter, False)
